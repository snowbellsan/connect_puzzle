<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>„Ç≥„Éç„ÇØ„Éà„Éë„Ç∫„É´„Ç≤„Éº„É†</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #000033 0%, #000055 100%);
            color: #ffffff;
            font-family: Arial, sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            border: 5px solid #0056b3;
            border-radius: 10px;
            background-color: #001144;
            padding: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            position: relative;
            touch-action: none;
        }

        h1 {
            text-align: center;
            margin: 10px 0;
            font-size: 1.8em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #game-board {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            grid-template-rows: repeat(10, 1fr);
            width: 300px;
            height: 500px;
            position: relative;
            overflow: hidden;
            background-color: #001f66;
            border: 2px solid #0056b3;
            touch-action: none;
        }

        #game-info {
            width: 300px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 1em;
            padding: 0 5px;
        }

        #controls {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
            gap: 10px;
        }

        #controls button {
            flex: 1;
            padding: 10px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #0056b3;
            color: white;
            transition: background-color 0.2s;
        }

        #controls button:hover {
            background-color: #003d82;
        }

        #controls button:active {
            transform: scale(0.95);
        }

        .ball {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            margin: auto;
            position: relative;
            z-index: 10;
            cursor: pointer;
            transition: grid-row-start 0.5s ease-out, transform 0.5s ease-out;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        .color-1 { background-color: #ff3333; }
        .color-2 { background-color: #3333ff; }
        .color-3 { background-color: #33ff33; }
        .color-4 { background-color: #ffff33; }
        .color-5 { 
            background: linear-gradient(45deg, #ff0000, #ff8000, #ffff00, #00ff00, #0000ff, #8a2be2);
            border: 3px solid #ffffff;
        } 

        .ball.highlight {
            box-shadow: 0 0 15px 5px rgba(255, 255, 255, 0.8), 0 3px 6px rgba(0, 0, 0, 0.5);
            transform: scale(1.1);
            z-index: 20;
        }
        
        .ball.vanishing {
            animation: vanish-animation 0.4s forwards;
            pointer-events: none;
        }

        @keyframes vanish-animation {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.1); opacity: 0; }
        }

        .floating-score {
            position: absolute;
            color: #ffff00;
            font-weight: bold;
            font-size: 1.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 50;
            animation: float-up 1s ease-out forwards;
        }

        @keyframes float-up {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translateY(-50px) scale(1.2);
                opacity: 0;
            }
        }

        .combo-text {
            position: absolute;
            color: #ff00ff;
            font-weight: bold;
            font-size: 2em;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 60;
            transform: translate(-50%, -50%);
            animation: combo-pulse 1.5s ease-out forwards;
        }

        @keyframes combo-pulse {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.3);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0;
            }
        }

        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
            border-radius: 10px;
        }

        #overlay.active {
            display: flex;
        }

        #overlay h2 {
            margin: 10px 0;
            font-size: 2em;
        }

        #overlay p {
            font-size: 1.3em;
            margin: 10px 0;
        }

        #overlay button {
            padding: 15px 30px;
            margin-top: 20px;
            font-size: 1.3em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #0056b3;
            color: white;
            transition: background-color 0.2s;
        }

        #overlay button:hover {
            background-color: #003d82;
        }

        .high-score-display {
            text-align: center;
            margin-top: 5px;
            font-size: 0.9em;
            color: #ffcc00;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1></h1>
        
        <div class="high-score-display">„Éè„Ç§„Çπ„Ç≥„Ç¢: <span id="high-score">0</span></div>
        
        <div id="game-info">
            <p>‚è±Ô∏è <span id="timer">60</span>Áßí</p>
            <p>üéØ <span id="score">0</span></p>
            <p>üî• <span id="combo">0</span>ÈÄ£Èéñ</p>
        </div>

        <div id="game-board"></div>
        
        <div id="controls">
            <button id="pause-btn">„Éù„Éº„Ç∫</button>
            <button id="sound-toggle">üîä</button>
        </div>
        
        <div id="overlay">
            <h2>üéâ ÊôÇÈñìÂàá„Çå</h2>
            <p>ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: <span id="final-score">0</span></p>
            <button onclick="window.location.reload()">„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Éó„É¨„Ç§</button>
        </div>
    </div>
    
    <audio id="bgm" src="assets/The_Seasons_Go_Around.mp3" loop></audio>
    <audio id="se_vanish" src="assets/„É¨„Éà„É≠„Ç¢„ÇØ„Ç∑„Éß„É≥.mp3"></audio> 
    <audio id="se_path" src="assets/„Éï„Ç°„Éã„Éº„Ç∏„É£„É≥„Éó.mp3"></audio>
    
    <script>
// ===============================================================
// Puyo Quest Style Connect Puzzle Game - game.js (ÊîπÂñÑÁâà)
// ===============================================================

// --- A. ÂÆöÊï∞„Å®ÂàùÊúüÂåñ ---

const COLS = 6;
const ROWS = 10;
const COLOR_COUNT = 4;
const RAINBOW_COLOR_ID = 5;
const MIN_CONNECT = 4; // 4„Å§‰ª•‰∏ä„ÅßÊ∂à„Åà„Çã

// DOMË¶ÅÁ¥†
const BOARD_ELEMENT = document.getElementById('game-board');
const SCORE_ELEMENT = document.getElementById('score');
const TIMER_ELEMENT = document.getElementById('timer');
const COMBO_ELEMENT = document.getElementById('combo');
const FINAL_SCORE_ELEMENT = document.getElementById('final-score');
const OVERLAY_ELEMENT = document.getElementById('overlay');
const HIGH_SCORE_ELEMENT = document.getElementById('high-score');
const PAUSE_BUTTON = document.getElementById('pause-btn');
const SOUND_TOGGLE = document.getElementById('sound-toggle');

// „Ç™„Éº„Éá„Ç£„Ç™Ë¶ÅÁ¥†
const BGM_ELEMENT = document.getElementById('bgm');
const VANISH_SOUND_ELEMENT = document.getElementById('se_vanish');
const PATH_SOUND_ELEMENT = document.getElementById('se_path');

// „Ç≤„Éº„É†Áä∂ÊÖãÂ§âÊï∞
let gameGrid = [];
let ballElementMap = {}; // ‰ΩçÁΩÆ‚ÜíË¶ÅÁ¥†„ÅÆ„Éû„ÉÉ„Éó („Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊîπÂñÑ)
let selectedPath = [];
let isDragging = false;
let score = 0;
let highScore = 0;
let timeRemaining = 60;
let comboCount = 0;
let gameInterval;
let isProcessing = false;
let isPaused = false;
let soundEnabled = true;
let isBGMPlaying = false;

// --- „Ç≤„Éº„É†ÈñãÂßã„Å®„É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ ---

document.addEventListener('DOMContentLoaded', () => {
    loadHighScore();
    initializeGame();
    setupPauseButton();
    setupSoundToggle();
});

function initializeGame() {
    score = 0;
    timeRemaining = 60;
    comboCount = 0;
    isProcessing = false;
    isDragging = false;
    isPaused = false;
    
    // BGM„ÅÆÊ∫ñÂÇô
    isBGMPlaying = false;
    if (BGM_ELEMENT) {
        BGM_ELEMENT.muted = true;
        BGM_ELEMENT.volume = 0.4;
    }
    
    gameGrid = [];
    ballElementMap = {};
    
    for (let r = 0; r < ROWS; r++) {
        gameGrid[r] = [];
        for (let c = 0; c < COLS; c++) {
            gameGrid[r][c] = getRandomColor(true); // ÂàùÊúüÈÖçÁΩÆ„Åß„ÇÇËôπËâ≤„Çí1%„ÅßÂá∫Áèæ
        }
    }
    
    initialRender();
    setupEventListeners();
    startGameTimer();
    updateDisplay();
}

function updateDisplay() {
    SCORE_ELEMENT.textContent = score;
    TIMER_ELEMENT.textContent = timeRemaining;
    COMBO_ELEMENT.textContent = comboCount;
    if (HIGH_SCORE_ELEMENT) HIGH_SCORE_ELEMENT.textContent = highScore;
}

function getRandomColor(allowRainbow = true) {
    // ÂàùÊúüÈÖçÁΩÆ„Åß„ÅØ1%„ÄÅÈÄöÂ∏∏„ÅØ3%„ÅÆÁ¢∫Áéá„ÅßËôπËâ≤
    const rainbowChance = allowRainbow ? 0.01 : 0;
    if (Math.random() < rainbowChance) { 
        return RAINBOW_COLOR_ID;
    }
    return Math.floor(Math.random() * COLOR_COUNT) + 1;
}

function getRandomColorForRefill() {
    // „É™„Éï„Ç£„É´ÊôÇ„ÅØ3%„ÅßËôπËâ≤
    if (Math.random() < 0.03) { 
        return RAINBOW_COLOR_ID;
    }
    return Math.floor(Math.random() * COLOR_COUNT) + 1;
}

// ÂàùÂõûÊèèÁîªÊôÇ„Å´„Éú„Éº„É´„ÇíÈÖçÁΩÆ„Åô„Çã
function initialRender() {
    BOARD_ELEMENT.querySelectorAll('.ball').forEach(ball => ball.remove());
    ballElementMap = {};
    
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (gameGrid[r][c] !== 0) {
                const ball = createBallElement(r, c, gameGrid[r][c]);
                ball.style.gridRowStart = r + 1;
            }
        }
    }
}

function createBallElement(r, c, colorId) {
    const ball = document.createElement('div');
    ball.classList.add('ball', `color-${colorId}`);
    
    ball.dataset.row = r;
    ball.dataset.col = c;
    ball.dataset.color = colorId;

    ball.style.gridColumnStart = c + 1;
    
    BOARD_ELEMENT.appendChild(ball);
    ballElementMap[`${r},${c}`] = ball; // „Éû„ÉÉ„Éó„Å´ÁôªÈå≤
    return ball;
}

// ÊèèÁîªÊúÄÈÅ©Âåñ„É≠„Ç∏„ÉÉ„ÇØÔºöÊó¢Â≠ò„ÅÆDOMË¶ÅÁ¥†„ÇíÁßªÂãï„Åï„Åõ„ÄÅÊñ∞„Åó„ÅÑ„Éú„Éº„É´„ÇíËøΩÂä†„Åô„Çã
function updateBallPositions() {
    const fragment = document.createDocumentFragment();
    const newBalls = [];
    
    for (let c = 0; c < COLS; c++) {
        const existingBallsInCol = Array.from(
            BOARD_ELEMENT.querySelectorAll(`.ball[data-col="${c}"]`)
        ).sort((a, b) => parseInt(a.dataset.row) - parseInt(b.dataset.row));

        let existingIndex = 0;

        for (let r = 0; r < ROWS; r++) {
            const colorId = gameGrid[r][c];

            if (existingIndex < existingBallsInCol.length) {
                const ball = existingBallsInCol[existingIndex];
                
                ball.dataset.row = r;
                ball.dataset.color = colorId;
                ball.className = `ball color-${colorId}`; 
                
                // „Éê„ÉÉ„ÉÅÊõ¥Êñ∞„ÅÆ„Åü„ÇÅ‰∏ÄÊôÇÁöÑ„Å´ÂÄ§„Çí‰øùÂ≠ò
                newBalls.push({ball, row: r});
                ballElementMap[`${r},${c}`] = ball;

                existingIndex++;
            } 
            else if (colorId !== 0) {
                const newBall = createBallElement(r, c, colorId);
                newBall.style.gridRowStart = r - ROWS;
                fragment.appendChild(newBall);
                newBalls.push({ball: newBall, row: r, isNew: true});
            }
        }
    }
    
    // Êñ∞„Åó„ÅÑ„Éú„Éº„É´„Çí‰∏ÄÊã¨ËøΩÂä†
    if (fragment.hasChildNodes()) {
        BOARD_ELEMENT.appendChild(fragment);
    }
    
    // „É™„Éï„É≠„ÉºÊúÄÂ∞èÂåñÔºögridRowStart„Çí‰∏ÄÊã¨Êõ¥Êñ∞
    requestAnimationFrame(() => {
        newBalls.forEach(({ball, row, isNew}) => {
            ball.style.gridRowStart = row + 1;
        });
    });
}

function startGameTimer() {
    if (gameInterval) clearInterval(gameInterval);
    gameInterval = setInterval(() => {
        if (!isPaused && timeRemaining > 0 && !isProcessing) {
            timeRemaining--;
            updateDisplay();
        } else if (timeRemaining <= 0 && !isProcessing) {
            clearInterval(gameInterval);
            gameOver();
        }
    }, 1000);
}

function gameOver() {
    isProcessing = true;
    FINAL_SCORE_ELEMENT.textContent = score;
    
    // „Éè„Ç§„Çπ„Ç≥„Ç¢Êõ¥Êñ∞
    if (score > highScore) {
        highScore = score;
        saveHighScore();
    }
    
    const overlay = document.getElementById('overlay');
    if (overlay) overlay.classList.add('active');
    
    // BGM„ÇíÂÅúÊ≠¢
    if (BGM_ELEMENT) {
        BGM_ELEMENT.pause();
        isBGMPlaying = false;
    }
}

// „Éè„Ç§„Çπ„Ç≥„Ç¢ÁÆ°ÁêÜ
function loadHighScore() {
    const saved = localStorage.getItem('puyoquest_highscore');
    highScore = saved ? parseInt(saved) : 0;
}

function saveHighScore() {
    localStorage.setItem('puyoquest_highscore', highScore);
}

// „Éù„Éº„Ç∫Ê©üËÉΩ
function setupPauseButton() {
    if (PAUSE_BUTTON) {
        PAUSE_BUTTON.addEventListener('click', togglePause);
    }
}

function togglePause() {
    if (timeRemaining <= 0 || isProcessing) return;
    
    isPaused = !isPaused;
    if (PAUSE_BUTTON) {
        PAUSE_BUTTON.textContent = isPaused ? 'ÂÜçÈñã' : '„Éù„Éº„Ç∫';
    }
    
    // BGM„ÅÆ‰∏ÄÊôÇÂÅúÊ≠¢/ÂÜçÈñã
    if (isPaused && BGM_ELEMENT && !BGM_ELEMENT.paused) {
        BGM_ELEMENT.pause();
    } else if (!isPaused && isBGMPlaying && BGM_ELEMENT && soundEnabled) {
        BGM_ELEMENT.play().catch(e => {});
    }
}

// „Çµ„Ç¶„É≥„Éâ„Éà„Ç∞„É´
function setupSoundToggle() {
    if (SOUND_TOGGLE) {
        SOUND_TOGGLE.addEventListener('click', toggleSound);
        updateSoundButton();
    }
}

function toggleSound() {
    soundEnabled = !soundEnabled;
    updateSoundButton();
    
    // BGM„ÅÆÂà∂Âæ°
    if (BGM_ELEMENT) {
        if (soundEnabled && isBGMPlaying && !isPaused) {
            BGM_ELEMENT.volume = 0.4;
            BGM_ELEMENT.play().catch(e => {});
        } else {
            BGM_ELEMENT.pause();
        }
    }
}

function updateSoundButton() {
    if (SOUND_TOGGLE) {
        SOUND_TOGGLE.textContent = soundEnabled ? 'üîä' : 'üîá';
    }
}

// --- B. Êìç‰ΩúÔºà„Ç≥„É≥„Éë„ÇØ„ÉàÔºâ„É≠„Ç∏„ÉÉ„ÇØ ---

function setupEventListeners() {
    BOARD_ELEMENT.addEventListener('mousedown', startDrag);
    BOARD_ELEMENT.addEventListener('touchstart', startDrag, { passive: true });
    
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', endDrag);
    BOARD_ELEMENT.addEventListener('touchmove', drag, { passive: false });
    BOARD_ELEMENT.addEventListener('touchend', endDrag);
}

function startDrag(e) {
    if (isProcessing || timeRemaining <= 0 || isPaused) return;
    
    // BGMÂàùÂõûÂÜçÁîü„É≠„Ç∏„ÉÉ„ÇØ
    if (!isBGMPlaying && BGM_ELEMENT && soundEnabled) {
        BGM_ELEMENT.muted = false;
        BGM_ELEMENT.volume = 0.4;
        BGM_ELEMENT.play().catch(error => {
            console.log("BGM„ÅÆÂÜçÁîü„Å´Â§±Êïó„Åó„Åæ„Åó„Åü:", error);
        });
        isBGMPlaying = true;
    }

    const targetElement = e.target.closest('.ball');
    if (!targetElement) return;
    
    // „Éë„ÇπÈñãÂßãÈü≥
    if (PATH_SOUND_ELEMENT && soundEnabled) {
        PATH_SOUND_ELEMENT.currentTime = 0;
        PATH_SOUND_ELEMENT.volume = 0.5;
        PATH_SOUND_ELEMENT.play().catch(error => {});
    }

    isDragging = true;
    selectedPath = [];
    comboCount = 0;
    addBallToPath(targetElement);
}

function drag(e) {
    if (!isDragging || isPaused) return;
    if (e.cancelable) e.preventDefault();
    
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    
    const targetElement = document.elementFromPoint(clientX, clientY);

    if (targetElement && targetElement.classList.contains('ball')) {
        addBallToPath(targetElement);
    }
}

function endDrag() {
    if (!isDragging) return;
    isDragging = false;
    
    if (selectedPath.length >= MIN_CONNECT) {
        processConnect(selectedPath);
    } 
    else if (selectedPath.length === 1 && selectedPath[0].color === RAINBOW_COLOR_ID) {
        processRainbowTap(selectedPath[0].r, selectedPath[0].c);
    } 
    else {
        clearHighlight();
    }
    
    selectedPath = [];
}

function clearHighlight() {
    BOARD_ELEMENT.querySelectorAll('.ball').forEach(ball => {
        ball.classList.remove('highlight');
    });
}

function addBallToPath(ballElement) {
    const r = parseInt(ballElement.dataset.row);
    const c = parseInt(ballElement.dataset.col);
    const color = parseInt(ballElement.dataset.color);
    const last = selectedPath[selectedPath.length - 1];
    
    if (!last) {
        selectedPath.push({ r, c, color, element: ballElement });
        ballElement.classList.add('highlight');
        return;
    }

    const existingIndex = selectedPath.findIndex(p => p.r === r && p.c === c);
    if (existingIndex !== -1) {
        if (existingIndex === selectedPath.length - 2) {
            selectedPath.pop().element.classList.remove('highlight');
        }
        return;
    }

    // 8ÊñπÂêë„ÅÆÈö£Êé•Âà§ÂÆö
    const isAdjacent = Math.abs(r - last.r) <= 1 && Math.abs(c - last.c) <= 1;
    if (!isAdjacent) return;

    const pathColor = selectedPath[0].color;
    const isSameColor = (color === pathColor) || (color === RAINBOW_COLOR_ID) || (pathColor === RAINBOW_COLOR_ID);

    if (isSameColor) {
        // „Éë„ÇπÂª∂Èï∑Èü≥
        if (PATH_SOUND_ELEMENT && soundEnabled) {
            PATH_SOUND_ELEMENT.currentTime = 0;
            PATH_SOUND_ELEMENT.volume = 0.5;
            PATH_SOUND_ELEMENT.play().catch(error => {});
        }
        
        selectedPath.push({ r, c, color, element: ballElement });
        ballElement.classList.add('highlight');
    }
}

// --- C. Ê∂àÂéª„ÄÅËêΩ‰∏ã„ÄÅÈÄ£Èéñ„É≠„Ç∏„ÉÉ„ÇØ („Ç≥„Ç¢) ---

function processConnect(path) {
    clearHighlight();
    isProcessing = true;

    const ballsToVanish = path.map(p => ({r: p.r, c: p.c, element: p.element}));

    const baseScore = path.length * 10;
    score += baseScore;
    showFloatingScore(baseScore, path[0].element);
    updateDisplay();

    vanishBalls(ballsToVanish).then(() => {
        startGravityAndChain();
    });
}

// ËôπËâ≤„Éú„Éº„É´Âá¶ÁêÜÔºö3x3„ÅÆÂ°ä„ÇíÊ∂àÂéª„Åô„Çã
function processRainbowTap(centerR, centerC) {
    isProcessing = true;
    comboCount = 0;
    clearHighlight();
    
    const ballsToVanish = [];
    for (let r = centerR - 1; r <= centerR + 1; r++) {
        for (let c = centerC - 1; c <= centerC + 1; c++) {
            if (r >= 0 && r < ROWS && c >= 0 && c < COLS && gameGrid[r][c] !== 0) {
                const element = ballElementMap[`${r},${c}`];
                if (element) {
                     ballsToVanish.push({r, c, element});
                     score += 20; 
                }
            }
        }
    }
    updateDisplay();

    vanishBalls(ballsToVanish).then(() => {
        startGravityAndChain();
    });
}

function vanishBalls(balls) {
    return new Promise(resolve => {
        // Ê∂àÂéªÈü≥
        if (VANISH_SOUND_ELEMENT && soundEnabled) {
            VANISH_SOUND_ELEMENT.currentTime = 0;
            VANISH_SOUND_ELEMENT.volume = 0.5;
            VANISH_SOUND_ELEMENT.play().catch(error => {});
        }
        
        balls.forEach(p => {
            p.element.classList.add('vanishing');
        });

        balls.forEach(p => {
            gameGrid[p.r][p.c] = 0;
            delete ballElementMap[`${p.r},${p.c}`]; // „Éû„ÉÉ„Éó„Åã„ÇâÂâäÈô§
        });

        setTimeout(() => {
            balls.forEach(p => p.element.remove());
            resolve();
        }, 450); 
    });
}

function startGravityAndChain() {
    isProcessing = true;
    checkChainLoop();
}

function checkChainLoop() {
    applyGravity();
    fillEmptySpaces();

    updateBallPositions();

    setTimeout(() => {
        const chainFound = findAndVanishChains();
        
        if (chainFound.length > 0) {
            comboCount++;
            // ÈÄ£Èéñ„Éú„Éº„Éä„Çπ„ÇíÁ∑©Âíå: Âπ≥ÊñπÊ†π„Çí‰ΩøÁî®
            const chainScore = chainFound.length * 30 * Math.ceil(Math.sqrt(comboCount));
            score += chainScore;
            
            showComboText(comboCount);
            updateDisplay();
            
            vanishBalls(chainFound).then(() => {
                checkChainLoop(); 
            });
        } else {
            comboCount = 0;
            isProcessing = false;
            updateDisplay();
        }
    }, 550); 
}

function applyGravity() {
    for (let c = 0; c < COLS; c++) {
        let writeRow = ROWS - 1;
        for (let r = ROWS - 1; r >= 0; r--) {
            if (gameGrid[r][c] !== 0) {
                if (r !== writeRow) {
                    gameGrid[writeRow][c] = gameGrid[r][c];
                    gameGrid[r][c] = 0;
                }
                writeRow--;
            }
        }
    }
}

function fillEmptySpaces() {
    for (let c = 0; c < COLS; c++) {
        for (let r = 0; r < ROWS; r++) {
            if (gameGrid[r][c] === 0) {
                const newColorId = getRandomColorForRefill();
                gameGrid[r][c] = newColorId;
            }
        }
    }
}

// „Å∑„Çà„ÇØ„Ç®ÈÄ£Èéñ‰ªïÊßòÔºöÁ∏¶„ÄÅÊ®™„ÄÅÊñú„ÇÅ„ÅÆ4ÊñπÂêë„ÅÆÁõ¥Á∑ö„Åß3„Å§‰ª•‰∏ä„ÇíÊ§úÂá∫
function findAndVanishChains() {
    const vanishingBalls = [];
    const checked = new Set();
    
    // 1. Á∏¶ÊñπÂêë„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
    for (let c = 0; c < COLS; c++) {
        for (let r = 0; r <= ROWS - MIN_CONNECT; r++) {
            const color = gameGrid[r][c];
            if (color === 0) continue;
            let length = 0;
            for (let i = r; i < ROWS; i++) {
                if (gameGrid[i][c] === color) { length++; } else { break; }
            }
            if (length >= MIN_CONNECT) {
                for (let i = 0; i < length; i++) {
                    const key = `${r + i},${c}`;
                    if (!checked.has(key)) {
                        const checkR = r + i;
                        const element = ballElementMap[key];
                        if(element) vanishingBalls.push({r: checkR, c, element});
                        checked.add(key);
                        gameGrid[checkR][c] = 0;
                    }
                }
            }
        }
    }

    // 2. Ê®™ÊñπÂêë„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c <= COLS - MIN_CONNECT; c++) {
            const color = gameGrid[r][c];
            if (color === 0) continue;
            let length = 0;
            for (let i = c; i < COLS; i++) {
                if (gameGrid[r][i] === color) { length++; } else { break; }
            }
            if (length >= MIN_CONNECT) {
                for (let i = 0; i < length; i++) {
                    const key = `${r},${c + i}`;
                    if (!checked.has(key)) {
                        const checkC = c + i;
                        const element = ballElementMap[key];
                        if(element) vanishingBalls.push({r, c: checkC, element});
                        checked.add(key);
                        gameGrid[r][checkC] = 0;
                    }
                }
            }
        }
    }

    // 3. ÂØæËßíÁ∑ö(Âè≥‰∏ã„Åå„Çä: \ )„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
    for (let r = 0; r <= ROWS - MIN_CONNECT; r++) {
        for (let c = 0; c <= COLS - MIN_CONNECT; c++) {
            const color = gameGrid[r][c];
            if (color === 0) continue;
            let length = 0;
            for (let i = 0; r + i < ROWS && c + i < COLS; i++) {
                if (gameGrid[r + i][c + i] === color) { length++; } else { break; }
            }
            if (length >= MIN_CONNECT) {
                for (let i = 0; i < length; i++) {
                    const checkR = r + i;
                    const checkC = c + i;
                    const key = `${checkR},${checkC}`;
                    if (!checked.has(key)) {
                        const element = ballElementMap[key];
                        if(element) vanishingBalls.push({r: checkR, c: checkC, element});
                        checked.add(key);
                        gameGrid[checkR][checkC] = 0;
                    }
                }
            }
        }
    }

    // 4. ÂØæËßíÁ∑ö(Â∑¶‰∏ã„Åå„Çä: / )„ÅÆ„ÉÅ„Çß„ÉÉ„ÇØ
    for (let r = 0; r <= ROWS - MIN_CONNECT; r++) {
        for (let c = MIN_CONNECT - 1; c < COLS; c++) { 
            const color = gameGrid[r][c];
            if (color === 0) continue;
            let length = 0;
            for (let i = 0; r + i < ROWS && c - i >= 0; i++) {
                if (gameGrid[r + i][c - i] === color) { length++; } else { break; }
            }
            if (length >= MIN_CONNECT) {
                for (let i = 0; i < length; i++) {
                    const checkR = r + i;
                    const checkC = c - i;
                    const key = `${checkR},${checkC}`;
                    if (!checked.has(key)) {
                        const element = ballElementMap[key];
                        if(element) vanishingBalls.push({r: checkR, c: checkC, element});
                        checked.add(key);
                        gameGrid[checkR][checkC] = 0;
                    }
                }
            }
        }
    }
    
    return vanishingBalls;
}

// --- D. Ë¶ñË¶öÁöÑ„Éï„Ç£„Éº„Éâ„Éê„ÉÉ„ÇØ ---

function showFloatingScore(points, element) {
    const floatingText = document.createElement('div');
    floatingText.className = 'floating-score';
    floatingText.textContent = `+${points}`;
    
    const rect = element.getBoundingClientRect();
    const boardRect = BOARD_ELEMENT.getBoundingClientRect();
    
    floatingText.style.left = (rect.left - boardRect.left + rect.width / 2) + 'px';
    floatingText.style.top = (rect.top - boardRect.top) + 'px';
    
    BOARD_ELEMENT.appendChild(floatingText);
    
    setTimeout(() => floatingText.remove(), 1000);
}

function showComboText(combo) {
    const comboText = document.createElement('div');
    comboText.className = 'combo-text';
    comboText.textContent = `${combo} ÈÄ£Èéñ!`;
    
    comboText.style.left = '50%';
    comboText.style.top = '50%';
    
    BOARD_ELEMENT.appendChild(comboText);
    
    setTimeout(() => comboText.remove(), 1500);
}
    </script>
</body>
</html>